{"version":3,"sources":["src/model/game.model.ts","src/helpers/radiant-transformer.ts","src/helpers/randomizer.ts","src/game/index.ts","index.ts"],"names":[],"mappings":"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","file":"game_touch.10c6d66a.js","sourceRoot":"..","sourcesContent":["export interface Game {\n    name: string;\n    level: number;\n    score: number;\n}\n\nexport interface MiddleCoordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Field {\n    radius: number;\n    backgroundColor: number;\n    middleCoordinate: MiddleCoordinate;\n}\n\nexport enum direction {\n    clockwise = -1,\n    сСlockwise = 1\n}\n\nexport interface Pointer {\n    direction: direction;\n    color: string;\n    angle: number;\n}\n\nexport interface Switcher {\n    rootAngle: number;\n    offsets: number;\n}\n","export const getRadians = (degrees: number) => (Math.PI / 180) * degrees;\n","export const randomIntegerInRange = (min: number, max: number): number =>\n    Math.floor(min + Math.random() * (max + 1 - min));\n","import { MiddleCoordinate, direction } from '../model/game.model';\nimport { getRadians } from '../helpers/radiant-transformer';\nimport { randomIntegerInRange } from '../helpers/randomizer';\n\nconst { clockwise, сСlockwise } = direction;\nconst domRectList = document.body.getClientRects();\nconst { width, height } = domRectList[0];\n\nconst canvasSize = width > height ? height : width;\nconst canvasMiddlePosition = canvasSize / 2;\nconst radius = canvasMiddlePosition * 0.9;\nconst innerRadius = radius / 3;\nconst minimumEnemyOffset = 20;\n\nconst canvasMiddlePoint: MiddleCoordinate = {\n    x: canvasMiddlePosition,\n    y: canvasMiddlePosition\n};\n\nconst { x, y } = canvasMiddlePoint;\nlet angle = 179;\nlet changeDirectionCounter = 5;\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\nctx.canvas.width = canvasSize;\nctx.canvas.height = canvasSize;\nctx.canvas.style.backgroundColor = 'white';\n\nconst setStaticFigures = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 1;\n    canvasCtx.strokeStyle = 'black';\n    canvasCtx.lineJoin = 'bevel';\n\n    canvasCtx.arc(x, y, radius, 0, getRadians(360));\n    canvasCtx.stroke();\n\n    canvasCtx.beginPath();\n    canvasCtx.arc(x, y, innerRadius, 0, getRadians(360));\n    canvasCtx.stroke();\n};\n\nlet pointerDirection = clockwise;\n\nconst setDocumentListener = (listener: () => void) => {\n    document.addEventListener('click', listener);\n    document.addEventListener('keydown', listener);\n};\nconst drowPointer = (angle: number, canvasCtx: CanvasRenderingContext2D, usedColor: string) => {\n    const angleRad = getRadians(angle);\n    const xPosition = radius * Math.sin(angleRad) + x;\n    const yPosition = radius * Math.cos(angleRad) + y;\n\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 4;\n    canvasCtx.lineJoin = 'round';\n    canvasCtx.strokeStyle = usedColor;\n    canvasCtx.moveTo(x, y);\n\n    canvasCtx.lineTo(xPosition, yPosition);\n    canvasCtx.stroke();\n};\n\nconst getUpdatedAngle = (updatedAngle: number, direction: number) => {\n    return direction === clockwise ? (updatedAngle <= 0 ? 360 : updatedAngle) : updatedAngle >= 360 ? 0 : updatedAngle;\n};\n\nconst performPointerItaration = (canvasCtx: CanvasRenderingContext2D) => {\n    drowPointer(angle, canvasCtx, 'blue');\n    angle = getUpdatedAngle(angle + pointerDirection, pointerDirection);\n};\n\nlet incrementId = -1;\n\nconst calclulateEnemy = (angle: number) => {\n    const minEnemyPosition = Math.abs(angle % 360) + minimumEnemyOffset;\n    const maxEnemyPosition = minEnemyPosition + 360 - minimumEnemyOffset;\n\n    const middlePointAngle = randomIntegerInRange(minimumEnemyOffset, maxEnemyPosition) % 360;\n    const distanceFromMiddlePoint = randomIntegerInRange(innerRadius, radius * 0.9);\n    const enemyRadius = randomIntegerInRange(innerRadius * 0.1, innerRadius * 0.4);\n\n    const angleRad = getRadians(middlePointAngle);\n    const xPosition = distanceFromMiddlePoint * Math.sin(angleRad) + x;\n    const yPosition = distanceFromMiddlePoint * Math.cos(angleRad) + y;\n\n    const angleOffset = (Math.atan(enemyRadius / distanceFromMiddlePoint) * 180) / Math.PI;\n\n    const min = middlePointAngle - angleOffset;\n    const max = middlePointAngle + angleOffset;\n\n    incrementId = incrementId + 1;\n\n    return {\n        xPosition,\n        yPosition,\n        enemyRadius,\n        middlePointAngle,\n        enemyAngleRange: [min, max],\n        enemyId: incrementId\n    };\n};\n\nconst state: any = {\n    enemies: []\n};\n\nconst drowEnemies = (enemies: any[], canvasCtx: CanvasRenderingContext2D) =>\n    enemies.forEach(({ xPosition, yPosition, enemyRadius }: any) => {\n        canvasCtx.beginPath();\n        canvasCtx.lineWidth = 1;\n        canvasCtx.strokeStyle = 'red';\n\n        canvasCtx.arc(xPosition, yPosition, enemyRadius, 0, getRadians(360));\n        canvasCtx.stroke();\n    });\n\nconst updateEnemies = (angle: number, canvasCtx: CanvasRenderingContext2D) => {\n    if (!state.enemies.length) {\n        state.enemies.push(calclulateEnemy(angle));\n    }\n\n    drowEnemies(state.enemies, canvasCtx);\n};\n\nconst addEnemy = (angle: number) => {\n    if (state.enemies.length < 10) {\n        state.enemies.push(calclulateEnemy(angle));\n    }\n};\n\nconst performCleanUp = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.beginPath();\n    canvasCtx.fillStyle = 'white';\n    canvasCtx.fillRect(0, 0, canvasSize, canvasSize);\n};\n\nconst drowChangeDirectionCounter = (canvasCtx: CanvasRenderingContext2D) => {\n    const messageWithCounter = `change direction tries: ${changeDirectionCounter}`;\n    const textColor = changeDirectionCounter ? 'black' : 'red';\n\n    canvasCtx.font = '25px Arial';\n    canvasCtx.fillStyle = textColor;\n    canvasCtx.fillText(messageWithCounter, 10, 40);\n};\n\nlet tickCounter = -1;\n\nconst validateEnemyCounts = (angle: any) => {\n    tickCounter = tickCounter + 1;\n\n    if (tickCounter >= 120) {\n        tickCounter = 0;\n        addEnemy(angle);\n    }\n};\n\nconst startGame = () => {\n    setInterval(() => {\n        performCleanUp(ctx);\n        setStaticFigures(ctx);\n        performPointerItaration(ctx);\n        validateEnemyCounts(angle);\n        updateEnemies(angle, ctx);\n        drowChangeDirectionCounter(ctx);\n    }, 10);\n};\n\nconst updateChangeDirectionCounter = (isEnemyInRange: boolean) => {\n    const shouldNotReduceCounter = !isEnemyInRange && changeDirectionCounter === 0;\n\n    if (shouldNotReduceCounter) {\n        return;\n    }\n\n    const diff = isEnemyInRange ? 1 : -1;\n    changeDirectionCounter = changeDirectionCounter + diff;\n};\n\nconst getUpdatedEnemyStatus = () => {\n    if (!state.enemies.length) {\n        return false;\n    }\n\n    const enemiesInRange = state.enemies\n        .filter(({ enemyAngleRange: [min, max] }: any) => {\n            const validatedAngle = angle === 360 ? 0 : angle;\n            const isEnemyInRange = validatedAngle > min && validatedAngle < max;\n\n            return isEnemyInRange;\n        })\n        .map(({ enemyId }: any) => enemyId);\n\n    let isEnemyInRange = false;\n\n    if (enemiesInRange.length) {\n        debugger;\n        state.enemies = state.enemies.filter(\n            (enemy: any) => !enemiesInRange.some((enemyId: number) => enemyId === enemy.enemyId)\n        );\n\n        isEnemyInRange = true;\n    }\n\n    return isEnemyInRange;\n};\n\nconst changePointerDirection = () => {\n    const isEnemyInRange = getUpdatedEnemyStatus();\n\n    if (changeDirectionCounter || isEnemyInRange) {\n        pointerDirection = pointerDirection === clockwise ? сСlockwise : clockwise;\n    }\n\n    updateChangeDirectionCounter(isEnemyInRange);\n};\n\nlet isGameStarted: boolean = false;\nconst addListenerToStartGame = (listener: () => void) => {\n    const button = document.getElementById('button');\n\n    if (!button) {\n        return;\n    }\n\n    button.addEventListener('keydown', event => event.preventDefault());\n    button.addEventListener('click', () => {\n        if (!isGameStarted) {\n            isGameStarted = true;\n            listener();\n            document.body.focus();\n        }\n    });\n};\nsetDocumentListener(changePointerDirection);\n\naddListenerToStartGame(startGame);\n","import './src/game/';\n"]}