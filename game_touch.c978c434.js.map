{"version":3,"sources":["src/model/game.model.ts","src/helpers/radiant-transformer.ts","src/game/constants.ts","src/game/renderer.ts","src/game/state.ts","node_modules/lodash.uniqueid/index.js","src/helpers/randomizer.ts","src/game/calculation/enemy.calculation.ts","src/game/calculation/rest-range.calculation.ts","src/game/index.ts","index.ts"],"names":[],"mappings":"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","file":"game_touch.c978c434.js","sourceRoot":"..","sourcesContent":["export interface Game {\n    name: string;\n    level: number;\n    score: number;\n}\n\nexport interface Coordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Field {\n    radius: number;\n    backgroundColor: number;\n    middleCoordinate: Coordinate;\n}\n\nexport enum direction {\n    clockwise = -1,\n    сСlockwise = 1\n}\n\nexport interface Pointer {\n    direction: direction;\n    color: string;\n    angle: number;\n}\n\nexport interface Switcher {\n    rootAngle: number;\n    offsets: number;\n}\n\nexport interface Enemy {\n    xPosition: number;\n    yPosition: number;\n    enemyRadius: number;\n    middlePointAngle: number;\n    enemyAngleRange: Array<number>;\n    enemyId: number;\n}\n\nexport interface State {\n    enemies: Array<Enemy>;\n    tickCounter: number;\n    countOfTicksWithoutEnemyDestory: number;\n    changeDirectionCounter: number;\n    angle: number;\n}\n\nexport interface LoaderData {\n    width: number;\n    color: string;\n}\n\nexport interface LoaderPostion {\n    position: number;\n    maxPosition: number;\n}\n","export type GetRadians = (degrees: number) => number;\nexport const getRadians = (degrees: number) => (Math.PI / 180) * degrees;\n","import { Coordinate } from '../model/game.model';\n\nexport const startAnglePosition = 179;\nexport const minimumEnemyOffset = 20;\nexport const maxEnemiesCount = 10;\n\nexport const maxDelayToAddEnemyInTicks = 360;\nexport const maxDelayInactionsInTicks = 180;\n\nexport const changeDirectionTriesMessage = 'direction counter:';\nexport const countOfEnemiesMessage = 'count of enemies:';\n\nexport const loaderWidth = 200;\nexport const loaderHeight = 15;\nexport const verticalLoaderOffset = 7;\nexport const loaderMinColor = '00ff00';\nexport const loaderMaxColor = 'ff0000';\n\nexport const countOfChangeDirectionTriesMessageCoordintate: Coordinate = {\n    x: 10,\n    y: 85\n};\n\nexport const countOfEnemiesMessagePositionCoordinate: Coordinate = {\n    x: 10,\n    y: 40\n};\n","import { Enemy, Coordinate, LoaderData } from '../model/game.model';\nimport { GetRadians } from '../helpers/radiant-transformer';\nimport { loaderHeight, loaderWidth, verticalLoaderOffset } from './constants';\n\nexport class CanvasRenderer {\n    private readonly defaultStartAngle: number = 0;\n    private readonly defaultEndAngle: number;\n\n    private readonly defaultLineWidth: number = 1;\n    private readonly pointerLineWidth: number = 4;\n    private readonly defaultLineJoin: CanvasLineJoin = 'round';\n\n    private readonly middleXCoordinate: number;\n    private readonly middleYCoordinate: number;\n\n    private readonly defaultStrokeStyleColor: string = 'black';\n    private cleanUpBackgroundColor: string = 'white';\n    private enemyStrokeStyleColor: string = 'red';\n    private pointerStyleColor: string = 'blue';\n    private defaultTextColor: string = 'black';\n\n    constructor(\n        private canvasCtx: CanvasRenderingContext2D,\n        private radius: number,\n        private innerRadius: number,\n        private canvasSize: number,\n        getRadians: GetRadians,\n        canvasMiddlePoint: Coordinate\n    ) {\n        this.defaultEndAngle = getRadians(360);\n\n        const { x, y } = canvasMiddlePoint;\n        this.middleXCoordinate = x;\n        this.middleYCoordinate = y;\n\n        this.initCanvas();\n    }\n\n    public drowStaticGameField() {\n        [this.innerRadius, this.radius].forEach((radius: number) => this.drowStrokedCircle(radius));\n    }\n\n    public drowEnemy(\n        radius: number,\n        x: number,\n        y: number,\n        strokeStyleColor: string = this.enemyStrokeStyleColor\n    ) {\n        this.drowStrokedCircle(radius, x, y, strokeStyleColor);\n    }\n\n    public canvasCleanUp() {\n        this.canvasCtx.beginPath();\n        this.canvasCtx.fillStyle = this.cleanUpBackgroundColor;\n        this.canvasCtx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n    }\n\n    public drowEnemies(enemies: Enemy[]) {\n        enemies.forEach(({ xPosition, yPosition, enemyRadius }: Enemy) =>\n            this.drowEnemy(enemyRadius, xPosition, yPosition)\n        );\n    }\n\n    public drowPointer(xPosition: number, yPosition: number) {\n        this.canvasCtx.beginPath();\n        this.setPathView(this.pointerStyleColor, this.pointerLineWidth, this.defaultLineJoin);\n\n        this.canvasCtx.moveTo(this.middleXCoordinate, this.middleYCoordinate);\n        this.canvasCtx.lineTo(xPosition, yPosition);\n\n        this.canvasCtx.stroke();\n    }\n\n    public drowText(\n        messageWithCounter: string,\n        { x, y }: Coordinate,\n        specificTextColor: string | null\n    ) {\n        this.canvasCtx.font = '25px Arial';\n        this.canvasCtx.fillStyle = specificTextColor || this.defaultTextColor;\n        this.canvasCtx.fillText(messageWithCounter, x, y);\n    }\n\n    public drowLoader({ x, y }: Coordinate, { width, color }: LoaderData) {\n        const yWithOffset = y + verticalLoaderOffset;\n\n        this.canvasCtx.beginPath();\n        this.canvasCtx.fillStyle = color;\n        this.canvasCtx.fillRect(x, yWithOffset, width, loaderHeight);\n\n        this.canvasCtx.beginPath();\n        this.canvasCtx.strokeStyle = this.defaultStrokeStyleColor;\n        this.canvasCtx.strokeRect(x, yWithOffset, loaderWidth, loaderHeight);\n    }\n\n    private drowStrokedCircle(\n        radius: number,\n        x: number = this.middleXCoordinate,\n        y: number = this.middleYCoordinate,\n        strokeStyleColor: string = this.defaultStrokeStyleColor,\n        lineWidth: number = this.defaultLineWidth,\n        startAngle: number = this.defaultStartAngle,\n        endAngle: number = this.defaultEndAngle,\n        lineJoin: CanvasLineJoin = this.defaultLineJoin\n    ) {\n        this.canvasCtx.beginPath();\n        this.setPathView(strokeStyleColor, lineWidth, lineJoin);\n\n        this.canvasCtx.arc(x, y, radius, startAngle, endAngle);\n        this.canvasCtx.stroke();\n    }\n\n    private initCanvas() {\n        this.canvasCtx.canvas.width = this.canvasSize;\n        this.canvasCtx.canvas.height = this.canvasSize;\n        this.canvasCtx.canvas.style.backgroundColor = this.cleanUpBackgroundColor;\n    }\n\n    private setPathView(strokeStyleColor: string, lineWidth: number, lineJoin: CanvasLineJoin) {\n        this.canvasCtx.strokeStyle = strokeStyleColor;\n        this.canvasCtx.lineWidth = lineWidth;\n        this.canvasCtx.lineJoin = lineJoin;\n    }\n}\n","import { startAnglePosition } from './constants';\nimport { State } from '../model/game.model';\n\nexport const state: State = {\n    enemies: [],\n    tickCounter: 0,\n    countOfTicksWithoutEnemyDestory: 0,\n    changeDirectionCounter: 5,\n    angle: startAnglePosition\n};\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nmodule.exports = uniqueId;\n","export const randomIntegerInRange = (min: number, max: number): number =>\n    Math.floor(min + Math.random() * (max + 1 - min));\n","import uniqueId from 'lodash.uniqueid';\n\nimport { Enemy, Coordinate } from '../../model/game.model';\nimport { minimumEnemyOffset } from '../constants';\nimport { getRadians } from '../../helpers/radiant-transformer';\nimport { randomIntegerInRange } from '../../helpers/randomizer';\n\nexport const createEnemy = (\n    angle: number,\n    innerRadius: number,\n    radius: number,\n    middlePointCoordinate: Coordinate\n): Enemy => {\n    const minEnemyPosition = Math.abs(angle % 360) + minimumEnemyOffset;\n    const maxEnemyPosition = minEnemyPosition + 360 - minimumEnemyOffset;\n\n    const middlePointAngle = randomIntegerInRange(minimumEnemyOffset, maxEnemyPosition) % 360;\n    const distanceFromMiddlePoint = randomIntegerInRange(innerRadius, radius * 0.9);\n    const enemyRadius = randomIntegerInRange(innerRadius * 0.1, innerRadius * 0.4);\n\n    const { x, y } = middlePointCoordinate;\n    const angleRad = getRadians(middlePointAngle);\n    const xPosition = distanceFromMiddlePoint * Math.sin(angleRad) + x;\n    const yPosition = distanceFromMiddlePoint * Math.cos(angleRad) + y;\n\n    const angleOffset = (Math.atan(enemyRadius / distanceFromMiddlePoint) * 180) / Math.PI;\n\n    const min = middlePointAngle - angleOffset;\n    const max = middlePointAngle + angleOffset;\n\n    return {\n        xPosition,\n        yPosition,\n        enemyRadius,\n        middlePointAngle,\n        enemyAngleRange: [min, max],\n        enemyId: uniqueId('enemy-id=')\n    };\n};\n","import { loaderMinColor, loaderMaxColor, loaderWidth } from '../constants';\nimport { LoaderData, LoaderPostion } from '../../model/game.model';\n\nconst transformHexToDec = (hex: string): number => parseInt(hex, 16);\nconst transformDecToHex = (dec: number): string => dec.toString(16);\nconst colorHexFormat = (hex: string): string => `#${hex.padStart(6, '0')}`;\n\nconst getPositionInPercents = (position: number, maxPosition: number): number =>\n    position / maxPosition;\nconst getValueBasedOnPercentsInRange = (percentage: number, min: number, max: number): number =>\n    percentage * (max - min) + min;\n\nconst [min, max] = [transformHexToDec(loaderMinColor), transformHexToDec(loaderMaxColor)];\n\nexport const getLoaderDataBasedOnCurrentLoaderCounterPosition = ({\n    position,\n    maxPosition\n}: LoaderPostion): LoaderData => {\n    const percentagesPosition = getPositionInPercents(position, maxPosition);\n    const decColorPosition = getValueBasedOnPercentsInRange(percentagesPosition, min, max);\n\n    return {\n        width: percentagesPosition * loaderWidth,\n        color: colorHexFormat(transformDecToHex(decColorPosition))\n    };\n};\n","import { Coordinate, direction, Enemy, State, LoaderPostion } from '../model/game.model';\nimport { getRadians } from '../helpers/radiant-transformer';\nimport { CanvasRenderer } from './renderer';\nimport { state } from './state';\nimport { createEnemy } from './calculation/enemy.calculation';\nimport {\n    maxEnemiesCount,\n    maxDelayToAddEnemyInTicks,\n    maxDelayInactionsInTicks,\n    changeDirectionTriesMessage,\n    countOfEnemiesMessage,\n    countOfChangeDirectionTriesMessageCoordintate,\n    countOfEnemiesMessagePositionCoordinate\n} from './constants';\nimport { getLoaderDataBasedOnCurrentLoaderCounterPosition } from './calculation/rest-range.calculation';\n\nconst { clockwise, сСlockwise } = direction;\nconst domRectList = document.body.getClientRects();\nconst { width, height } = domRectList[0];\n\nconst canvasSize = width > height ? height : width;\nconst canvasMiddlePosition = canvasSize / 2;\nconst radius = canvasMiddlePosition * 0.9;\nconst innerRadius = radius / 3;\n\nconst canvasMiddlePoint: Coordinate = {\n    x: canvasMiddlePosition,\n    y: canvasMiddlePosition\n};\n\nconst { x, y } = canvasMiddlePoint;\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n\nconst canvasRenderer = new CanvasRenderer(\n    ctx,\n    radius,\n    innerRadius,\n    canvasSize,\n    getRadians,\n    canvasMiddlePoint\n);\n\nlet pointerDirection = clockwise;\n\nconst setDocumentListener = (listener: () => void) => {\n    document.addEventListener('click', listener);\n    document.addEventListener('keydown', listener);\n};\nconst drowPointer = (angle: number) => {\n    const angleRad = getRadians(angle);\n    const xPosition = radius * Math.sin(angleRad) + x;\n    const yPosition = radius * Math.cos(angleRad) + y;\n\n    canvasRenderer.drowPointer(xPosition, yPosition);\n};\n\nconst getUpdatedAngle = (updatedAngle: number, direction: number) => {\n    return direction === clockwise\n        ? updatedAngle <= 0\n            ? 360\n            : updatedAngle\n        : updatedAngle >= 360\n        ? 0\n        : updatedAngle;\n};\n\nconst performPointerItaration = () => {\n    const { angle } = state;\n    drowPointer(state.angle);\n    state.angle = getUpdatedAngle(angle + pointerDirection, pointerDirection);\n};\n\nconst hasNoEnemies = ({ enemies }: State) => !enemies.length;\nconst hasLessEnemiesToMax = ({ enemies }: State) => enemies.length < maxEnemiesCount;\nconst isDirectionCounterEmpty = ({ changeDirectionCounter }: State) => !changeDirectionCounter;\n\nconst addNewEnemy = (enemy: Enemy) => (state.enemies = [...state.enemies, enemy]);\n\nconst addNewEnemyWithPassedValidator = (\n    shouldAddNewEnemyValidator: (state: State) => boolean,\n    state: State,\n    angle: number\n) => {\n    if (shouldAddNewEnemyValidator(state)) {\n        addNewEnemy(createEnemy(angle, innerRadius, radius, canvasMiddlePoint));\n    }\n};\n\nconst updateEnemies = (angle: number) => {\n    addNewEnemyWithPassedValidator(hasNoEnemies, state, angle);\n    canvasRenderer.drowEnemies(state.enemies);\n};\n\nconst addEnemy = (angle: number) => {\n    addNewEnemyWithPassedValidator(hasLessEnemiesToMax, state, angle);\n};\n\nconst drowCounterMessageWithLoader = (\n    staticPrefixMessage: string,\n    dynamicValue: number,\n    useSpecificColor: boolean,\n    textPositionCoordintate: Coordinate,\n    loaderPosition: LoaderPostion\n) => {\n    const messageWithCounter = `${staticPrefixMessage} ${dynamicValue}`;\n    const specificTextColor = useSpecificColor ? 'red' : null;\n\n    canvasRenderer.drowText(messageWithCounter, textPositionCoordintate, specificTextColor);\n    canvasRenderer.drowLoader(\n        textPositionCoordintate,\n        getLoaderDataBasedOnCurrentLoaderCounterPosition(loaderPosition)\n    );\n};\n\nconst drowTextMessagesWithLoader = (state: State) => {\n    drowCounterMessageWithLoader(\n        changeDirectionTriesMessage,\n        state.changeDirectionCounter,\n        isDirectionCounterEmpty(state),\n        countOfChangeDirectionTriesMessageCoordintate,\n        {\n            position: state.countOfTicksWithoutEnemyDestory,\n            maxPosition: maxDelayInactionsInTicks\n        }\n    );\n    drowCounterMessageWithLoader(\n        countOfEnemiesMessage,\n        state.enemies.length,\n        !hasLessEnemiesToMax(state),\n        countOfEnemiesMessagePositionCoordinate,\n        {\n            position: state.tickCounter,\n            maxPosition: maxDelayToAddEnemyInTicks\n        }\n    );\n};\n\nconst validateEnemyCounts = (angle: any) => {\n    state.tickCounter = state.tickCounter + 1;\n\n    if (state.tickCounter >= maxDelayToAddEnemyInTicks) {\n        state.tickCounter = 0;\n        addEnemy(angle);\n    }\n};\n\nconst validateTicksWithoutDestroy = () => {\n    state.countOfTicksWithoutEnemyDestory = state.countOfTicksWithoutEnemyDestory + 1;\n};\n\nconst cleanUpTicksWithoutEnemyDestroy = (isEnemyInRange: boolean) => {\n    if (isEnemyInRange) {\n        state.countOfTicksWithoutEnemyDestory = 0;\n    }\n};\n\nconst updateChangeDirectionCounter = (diff: number) => {\n    state.changeDirectionCounter = state.changeDirectionCounter + diff;\n\n    if (state.changeDirectionCounter < 0) {\n        state.changeDirectionCounter = 0;\n    }\n};\n\nconst reduceChangeDirectionCounterOnLongPending = () => {\n    if (state.countOfTicksWithoutEnemyDestory > maxDelayInactionsInTicks) {\n        cleanUpTicksWithoutEnemyDestroy(true);\n        updateChangeDirectionCounter(-1);\n    }\n};\n\nconst startGame = () => {\n    setInterval(() => {\n        canvasRenderer.canvasCleanUp();\n        canvasRenderer.drowStaticGameField();\n        performPointerItaration();\n\n        validateEnemyCounts(state.angle);\n        validateTicksWithoutDestroy();\n        reduceChangeDirectionCounterOnLongPending();\n\n        updateEnemies(state.angle);\n        drowTextMessagesWithLoader(state);\n    }, 10);\n};\n\nconst validateChangeDirectionCounter = (isEnemyInRange: boolean) => {\n    const { changeDirectionCounter } = state;\n    const shouldNotReduceCounter = !isEnemyInRange && changeDirectionCounter === 0;\n\n    if (shouldNotReduceCounter) {\n        return;\n    }\n\n    const diff = isEnemyInRange ? 1 : -1;\n    updateChangeDirectionCounter(diff);\n};\n\nconst getUpdatedEnemyStatus = () => {\n    if (!state.enemies.length) {\n        return false;\n    }\n\n    const { angle } = state;\n    const enemiesInRange = state.enemies\n        .filter(({ enemyAngleRange: [min, max] }: any) => {\n            const validatedAngle = angle === 360 ? 0 : angle;\n            const isEnemyInRange = validatedAngle > min && validatedAngle < max;\n\n            return isEnemyInRange;\n        })\n        .map(({ enemyId }: any) => enemyId);\n\n    let isEnemyInRange = false;\n\n    if (enemiesInRange.length) {\n        state.enemies = state.enemies.filter(\n            (enemy: any) => !enemiesInRange.some((enemyId: number) => enemyId === enemy.enemyId)\n        );\n\n        isEnemyInRange = true;\n    }\n\n    return isEnemyInRange;\n};\n\nconst changePointerDirection = () => {\n    const isEnemyInRange = getUpdatedEnemyStatus();\n    const { changeDirectionCounter } = state;\n    if (changeDirectionCounter || isEnemyInRange) {\n        pointerDirection = pointerDirection === clockwise ? сСlockwise : clockwise;\n    }\n\n    cleanUpTicksWithoutEnemyDestroy(isEnemyInRange);\n    validateChangeDirectionCounter(isEnemyInRange);\n};\n\nlet isGameStarted: boolean = false;\nconst addListenerToStartGame = (listener: () => void) => {\n    const button = document.getElementById('button');\n\n    if (!button) {\n        return;\n    }\n\n    button.addEventListener('keydown', event => event.preventDefault());\n    button.addEventListener('click', () => {\n        if (!isGameStarted) {\n            isGameStarted = true;\n            listener();\n            document.body.focus();\n        }\n    });\n};\nsetDocumentListener(changePointerDirection);\n\naddListenerToStartGame(startGame);\n","import './src/game/';\n"]}