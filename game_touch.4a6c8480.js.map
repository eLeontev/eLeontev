{"version":3,"sources":["src/model/game.model.ts","src/helpers/radiant-transformer.ts","src/helpers/randomizer.ts","src/game/renderer.ts","src/game/index.ts","index.ts"],"names":[],"mappings":"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","file":"game_touch.4a6c8480.js","sourceRoot":"..","sourcesContent":["export interface Game {\n    name: string;\n    level: number;\n    score: number;\n}\n\nexport interface Coordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Field {\n    radius: number;\n    backgroundColor: number;\n    middleCoordinate: Coordinate;\n}\n\nexport enum direction {\n    clockwise = -1,\n    сСlockwise = 1\n}\n\nexport interface Pointer {\n    direction: direction;\n    color: string;\n    angle: number;\n}\n\nexport interface Switcher {\n    rootAngle: number;\n    offsets: number;\n}\n\nexport interface Enemy {\n    xPosition: number;\n    yPosition: number;\n    enemyRadius: number;\n    middlePointAngle: number;\n    enemyAngleRange: Array<number>;\n    enemyId: number;\n}\n","export type GetRadians = (degrees: number) => number;\nexport const getRadians = (degrees: number) => (Math.PI / 180) * degrees;\n","export const randomIntegerInRange = (min: number, max: number): number =>\n    Math.floor(min + Math.random() * (max + 1 - min));\n","import { Enemy, Coordinate } from '../model/game.model';\nimport { GetRadians } from '../helpers/radiant-transformer';\n\nexport class CanvasRenderer {\n    private readonly defaultStartAngle: number = 0;\n    private readonly defaultEndAngle: number;\n\n    private readonly defaultLineWidth: number = 1;\n    private readonly pointerLineWidth: number = 4;\n    private readonly defaultLineJoin: CanvasLineJoin = 'round';\n\n    private readonly middleXCoordinate: number;\n    private readonly middleYCoordinate: number;\n\n    private readonly defaultStrokeStyleColor: string = 'black';\n    private cleanUpBackgroundColor: string = 'white';\n    private enemyStrokeStyleColor: string = 'red';\n    private pointerStyleColor: string = 'blue';\n    private defaultTextColor: string = 'black';\n\n    constructor(\n        private canvasCtx: CanvasRenderingContext2D,\n        private radius: number,\n        private innerRadius: number,\n        private canvasSize: number,\n        getRadians: GetRadians,\n        canvasMiddlePoint: Coordinate\n    ) {\n        this.defaultEndAngle = getRadians(360);\n\n        const { x, y } = canvasMiddlePoint;\n        this.middleXCoordinate = x;\n        this.middleYCoordinate = y;\n\n        this.initCanvas();\n    }\n\n    public drowStaticGameField() {\n        [this.innerRadius, this.radius].forEach((radius: number) => this.drowStrokedCircle(radius));\n    }\n\n    public drowEnemy(\n        radius: number,\n        x: number,\n        y: number,\n        strokeStyleColor: string = this.enemyStrokeStyleColor\n    ) {\n        this.drowStrokedCircle(radius, x, y, strokeStyleColor);\n    }\n\n    public canvasCleanUp() {\n        this.canvasCtx.beginPath();\n        this.canvasCtx.fillStyle = this.cleanUpBackgroundColor;\n        this.canvasCtx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n    }\n\n    public drowEnemies(enemies: Enemy[]) {\n        enemies.forEach(({ xPosition, yPosition, enemyRadius }: Enemy) =>\n            this.drowEnemy(enemyRadius, xPosition, yPosition)\n        );\n    }\n\n    public drowPointer(xPosition: number, yPosition: number) {\n        this.canvasCtx.beginPath();\n        this.setPathView(this.pointerStyleColor, this.pointerLineWidth, this.defaultLineJoin);\n\n        this.canvasCtx.moveTo(this.middleXCoordinate, this.middleYCoordinate);\n        this.canvasCtx.lineTo(xPosition, yPosition);\n\n        this.canvasCtx.stroke();\n    }\n\n    public drowText(\n        messageWithCounter: string,\n        { x, y }: Coordinate,\n        specificTextColor: string | null\n    ) {\n        this.canvasCtx.font = '25px Arial';\n        this.canvasCtx.fillStyle = specificTextColor || this.defaultTextColor;\n        this.canvasCtx.fillText(messageWithCounter, x, y);\n    }\n\n    private drowStrokedCircle(\n        radius: number,\n        x: number = this.middleXCoordinate,\n        y: number = this.middleYCoordinate,\n        strokeStyleColor: string = this.defaultStrokeStyleColor,\n        lineWidth: number = this.defaultLineWidth,\n        startAngle: number = this.defaultStartAngle,\n        endAngle: number = this.defaultEndAngle,\n        lineJoin: CanvasLineJoin = this.defaultLineJoin\n    ) {\n        this.canvasCtx.beginPath();\n        this.setPathView(strokeStyleColor, lineWidth, lineJoin);\n\n        this.canvasCtx.arc(x, y, radius, startAngle, endAngle);\n        this.canvasCtx.stroke();\n    }\n\n    private initCanvas() {\n        this.canvasCtx.canvas.width = this.canvasSize;\n        this.canvasCtx.canvas.height = this.canvasSize;\n        this.canvasCtx.canvas.style.backgroundColor = this.cleanUpBackgroundColor;\n    }\n\n    private setPathView(strokeStyleColor: string, lineWidth: number, lineJoin: CanvasLineJoin) {\n        this.canvasCtx.strokeStyle = strokeStyleColor;\n        this.canvasCtx.lineWidth = lineWidth;\n        this.canvasCtx.lineJoin = lineJoin;\n    }\n}\n","import { Coordinate, direction, Enemy } from '../model/game.model';\nimport { getRadians } from '../helpers/radiant-transformer';\nimport { randomIntegerInRange } from '../helpers/randomizer';\nimport { CanvasRenderer } from './renderer';\n\nconst state: any = {\n    enemies: [],\n    tickCounter: 0,\n    countOfTicksWithoutEnemyDestory: 0,\n    changeDirectionCounter: 5\n};\n\nconst { clockwise, сСlockwise } = direction;\nconst domRectList = document.body.getClientRects();\nconst { width, height } = domRectList[0];\n\nconst canvasSize = width > height ? height : width;\nconst canvasMiddlePosition = canvasSize / 2;\nconst radius = canvasMiddlePosition * 0.9;\nconst innerRadius = radius / 3;\nconst minimumEnemyOffset = 20;\n\nconst canvasMiddlePoint: Coordinate = {\n    x: canvasMiddlePosition,\n    y: canvasMiddlePosition\n};\n\nconst { x, y } = canvasMiddlePoint;\nlet angle = 179;\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n\nconst canvasRenderer = new CanvasRenderer(\n    ctx,\n    radius,\n    innerRadius,\n    canvasSize,\n    getRadians,\n    canvasMiddlePoint\n);\n\nlet pointerDirection = clockwise;\n\nconst setDocumentListener = (listener: () => void) => {\n    document.addEventListener('click', listener);\n    document.addEventListener('keydown', listener);\n};\nconst drowPointer = (angle: number) => {\n    const angleRad = getRadians(angle);\n    const xPosition = radius * Math.sin(angleRad) + x;\n    const yPosition = radius * Math.cos(angleRad) + y;\n\n    canvasRenderer.drowPointer(xPosition, yPosition);\n};\n\nconst getUpdatedAngle = (updatedAngle: number, direction: number) => {\n    return direction === clockwise\n        ? updatedAngle <= 0\n            ? 360\n            : updatedAngle\n        : updatedAngle >= 360\n        ? 0\n        : updatedAngle;\n};\n\nconst performPointerItaration = () => {\n    drowPointer(angle);\n    angle = getUpdatedAngle(angle + pointerDirection, pointerDirection);\n};\n\nlet incrementId = -1;\n\nconst calclulateEnemy = (angle: number): Enemy => {\n    const minEnemyPosition = Math.abs(angle % 360) + minimumEnemyOffset;\n    const maxEnemyPosition = minEnemyPosition + 360 - minimumEnemyOffset;\n\n    const middlePointAngle = randomIntegerInRange(minimumEnemyOffset, maxEnemyPosition) % 360;\n    const distanceFromMiddlePoint = randomIntegerInRange(innerRadius, radius * 0.9);\n    const enemyRadius = randomIntegerInRange(innerRadius * 0.1, innerRadius * 0.4);\n\n    const angleRad = getRadians(middlePointAngle);\n    const xPosition = distanceFromMiddlePoint * Math.sin(angleRad) + x;\n    const yPosition = distanceFromMiddlePoint * Math.cos(angleRad) + y;\n\n    const angleOffset = (Math.atan(enemyRadius / distanceFromMiddlePoint) * 180) / Math.PI;\n\n    const min = middlePointAngle - angleOffset;\n    const max = middlePointAngle + angleOffset;\n\n    incrementId = incrementId + 1;\n\n    return {\n        xPosition,\n        yPosition,\n        enemyRadius,\n        middlePointAngle,\n        enemyAngleRange: [min, max],\n        enemyId: incrementId\n    };\n};\n\nconst updateEnemies = (angle: number) => {\n    if (!state.enemies.length) {\n        state.enemies.push(calclulateEnemy(angle));\n    }\n\n    canvasRenderer.drowEnemies(state.enemies);\n};\n\nconst addEnemy = (angle: number) => {\n    if (state.enemies.length < 10) {\n        state.enemies.push(calclulateEnemy(angle));\n    }\n};\n\nconst drowChangeDirectionCounter = () => {\n    const { changeDirectionCounter } = state;\n    const messageWithCounter = `change direction tries: ${changeDirectionCounter}`;\n    const specificTextColor = !changeDirectionCounter ? 'red' : null;\n\n    canvasRenderer.drowText(messageWithCounter, { x: 10, y: 40 }, specificTextColor);\n};\n\nconst validateEnemyCounts = (angle: any) => {\n    state.tickCounter = state.tickCounter + 1;\n\n    if (state.tickCounter >= 180) {\n        state.tickCounter = 0;\n        addEnemy(angle);\n    }\n};\n\nconst validateTicksWithoutDestroy = () => {\n    state.countOfTicksWithoutEnemyDestory = state.countOfTicksWithoutEnemyDestory + 1;\n};\n\nconst cleanUpTicksWithoutEnemyDestroy = (isEnemyInRange: boolean) => {\n    if (isEnemyInRange) {\n        state.countOfTicksWithoutEnemyDestory = 0;\n    }\n};\n\nconst updateChangeDirectionCounter = (diff: number) => {\n    state.changeDirectionCounter = state.changeDirectionCounter + diff;\n\n    if (state.changeDirectionCounter < 0) {\n        state.changeDirectionCounter = 0;\n    }\n};\n\nconst reduceChangeDirectionCounterOnLongPending = () => {\n    if (state.countOfTicksWithoutEnemyDestory > 180) {\n        cleanUpTicksWithoutEnemyDestroy(true);\n        updateChangeDirectionCounter(-1);\n    }\n};\n\nconst startGame = () => {\n    setInterval(() => {\n        canvasRenderer.canvasCleanUp();\n        canvasRenderer.drowStaticGameField();\n        performPointerItaration();\n\n        validateEnemyCounts(angle);\n        validateTicksWithoutDestroy();\n        reduceChangeDirectionCounterOnLongPending();\n\n        updateEnemies(angle);\n        drowChangeDirectionCounter();\n    }, 10);\n};\n\nconst validateChangeDirectionCounter = (isEnemyInRange: boolean) => {\n    const { changeDirectionCounter } = state;\n    const shouldNotReduceCounter = !isEnemyInRange && changeDirectionCounter === 0;\n\n    if (shouldNotReduceCounter) {\n        return;\n    }\n\n    const diff = isEnemyInRange ? 1 : -1;\n    updateChangeDirectionCounter(diff);\n};\n\nconst getUpdatedEnemyStatus = () => {\n    if (!state.enemies.length) {\n        return false;\n    }\n\n    const enemiesInRange = state.enemies\n        .filter(({ enemyAngleRange: [min, max] }: any) => {\n            const validatedAngle = angle === 360 ? 0 : angle;\n            const isEnemyInRange = validatedAngle > min && validatedAngle < max;\n\n            return isEnemyInRange;\n        })\n        .map(({ enemyId }: any) => enemyId);\n\n    let isEnemyInRange = false;\n\n    if (enemiesInRange.length) {\n        state.enemies = state.enemies.filter(\n            (enemy: any) => !enemiesInRange.some((enemyId: number) => enemyId === enemy.enemyId)\n        );\n\n        isEnemyInRange = true;\n    }\n\n    return isEnemyInRange;\n};\n\nconst changePointerDirection = () => {\n    const isEnemyInRange = getUpdatedEnemyStatus();\n    const { changeDirectionCounter } = state;\n    if (changeDirectionCounter || isEnemyInRange) {\n        pointerDirection = pointerDirection === clockwise ? сСlockwise : clockwise;\n    }\n\n    cleanUpTicksWithoutEnemyDestroy(isEnemyInRange);\n    validateChangeDirectionCounter(isEnemyInRange);\n};\n\nlet isGameStarted: boolean = false;\nconst addListenerToStartGame = (listener: () => void) => {\n    const button = document.getElementById('button');\n\n    if (!button) {\n        return;\n    }\n\n    button.addEventListener('keydown', event => event.preventDefault());\n    button.addEventListener('click', () => {\n        if (!isGameStarted) {\n            isGameStarted = true;\n            listener();\n            document.body.focus();\n        }\n    });\n};\nsetDocumentListener(changePointerDirection);\n\naddListenerToStartGame(startGame);\n","import './src/game/';\n"]}