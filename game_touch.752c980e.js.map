{"version":3,"sources":["src/model/game.model.ts","src/helpers/radiant-transformer.ts","src/helpers/randomizer.ts","src/game/index.ts","index.ts"],"names":[],"mappings":"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","file":"game_touch.752c980e.js","sourceRoot":"..","sourcesContent":["export interface Game {\n    name: string;\n    level: number;\n    score: number;\n}\n\nexport interface MiddleCoordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Field {\n    radius: number;\n    backgroundColor: number;\n    middleCoordinate: MiddleCoordinate;\n}\n\nexport enum direction {\n    clockwise = -1,\n    сСlockwise = 1\n}\n\nexport interface Pointer {\n    direction: direction;\n    color: string;\n    angle: number;\n}\n\nexport interface Switcher {\n    rootAngle: number;\n    offsets: number;\n}\n","export const getRadians = (degrees: number) => (Math.PI / 180) * degrees;\n","export const randomIntegerInRange = (min: number, max: number): number => Math.floor(min + Math.random() * (max + 1 - min));\n","import { Game, MiddleCoordinate, direction } from '../model/game.model';\nimport { getRadians } from '../helpers/radiant-transformer';\nimport { randomIntegerInRange } from '../helpers/randomizer';\n\nconst { clockwise, сСlockwise } = direction;\nconst [{ width, height }]: DOMRectList = document.body.getClientRects();\nconst canvasSize = width > height ? height : width;\nconst canvasMiddlePosition = canvasSize / 2;\nconst radius = canvasMiddlePosition * 0.9;\nconst innerRadius = radius / 3;\nconst minimumEnemyOffset = 20;\n\nconst canvasMiddlePoint: MiddleCoordinate = {\n    x: canvasMiddlePosition,\n    y: canvasMiddlePosition\n};\n\nconst { x, y } = canvasMiddlePoint;\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d');\nctx.canvas.width = canvasSize;\nctx.canvas.height = canvasSize;\nctx.canvas.style.backgroundColor = 'white';\n\nconst setStaticFigures = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 1;\n    canvasCtx.strokeStyle = 'black';\n    canvasCtx.lineJoin = 'bevel';\n\n    canvasCtx.arc(x, y, radius, 0, getRadians(360));\n    canvasCtx.stroke();\n\n    canvasCtx.beginPath();\n    canvasCtx.arc(x, y, innerRadius, 0, getRadians(360));\n    canvasCtx.stroke();\n};\n\nlet angle = 179;\n\nlet pointerDirection = clockwise;\n\nconst setDocumentListener = (listener: () => void) => {\n    document.addEventListener('click', listener);\n    document.addEventListener('keydown', listener);\n};\nconst drowPointer = (angle: number, canvasCtx: CanvasRenderingContext2D, usedColor: string, isForClear: boolean) => {\n    const angleRad = getRadians(angle);\n    const xPosition = radius * Math.sin(angleRad) + x;\n    const yPosition = radius * Math.cos(angleRad) + y;\n\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = isForClear ? 4 + 2 : 4;\n    canvasCtx.lineJoin = 'round';\n    canvasCtx.strokeStyle = usedColor;\n    canvasCtx.moveTo(x, y);\n\n    canvasCtx.lineTo(xPosition, yPosition);\n    canvasCtx.stroke();\n};\n\nconst cleanUpPreviosPointer = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.lineWidth = 4 + 2;\n    canvasCtx.strokeStyle = 'white';\n    canvasCtx.stroke();\n};\n\nconst getUpdatedAngle = (updatedAngle: number, direction: number) => {\n    return direction === clockwise ? (updatedAngle <= 0 ? 360 : updatedAngle) : updatedAngle >= 360 ? 0 : updatedAngle;\n};\n\nconst performPointerItaration = (canvasCtx: CanvasRenderingContext2D) => {\n    cleanUpPreviosPointer(canvasCtx);\n    setStaticFigures(canvasCtx);\n    drowPointer(angle - pointerDirection, canvasCtx, 'white', true);\n    drowPointer(angle, canvasCtx, 'blue', false);\n    angle = getUpdatedAngle(angle + pointerDirection, pointerDirection);\n};\n\nconst calclulateEnemy = (angle: number) => {\n    const minEnemyPosition = Math.abs(angle % 360) + minimumEnemyOffset;\n    const maxEnemyPosition = minEnemyPosition + 360 - minimumEnemyOffset;\n\n    const middlePointAngle = randomIntegerInRange(minimumEnemyOffset, maxEnemyPosition) % 360;\n    const distanceFromMiddlePoint = randomIntegerInRange(innerRadius, radius * 0.9);\n    const enemyRadius = randomIntegerInRange(innerRadius * 0.1, innerRadius * 0.4);\n\n    const angleRad = getRadians(middlePointAngle);\n    const xPosition = distanceFromMiddlePoint * Math.sin(angleRad) + x;\n    const yPosition = distanceFromMiddlePoint * Math.cos(angleRad) + y;\n\n    const angleOffset = (Math.atan(enemyRadius / distanceFromMiddlePoint) * 180) / Math.PI;\n\n    const min = middlePointAngle - angleOffset;\n    const max = middlePointAngle + angleOffset;\n\n    return {\n        xPosition,\n        yPosition,\n        enemyRadius,\n        middlePointAngle,\n        enemyAngleRange: [min, max]\n    };\n};\n\nlet enemyCoords;\nconst drowEnemy = (angle: number, canvasCtx: CanvasRenderingContext2D) => {\n    if (!enemyCoords) {\n        enemyCoords = calclulateEnemy(angle);\n    }\n\n    const { xPosition, yPosition, enemyRadius } = enemyCoords;\n\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 1;\n    canvasCtx.strokeStyle = 'red';\n\n    canvasCtx.arc(xPosition, yPosition, enemyRadius, 0, getRadians(360));\n    canvasCtx.stroke();\n};\n\nconst startGame = () => {\n    setInterval(() => {\n        performPointerItaration(ctx);\n        drowEnemy(angle, ctx);\n    }, 10);\n};\n\nconst updateEnemyStatus = () => {\n    if (!enemyCoords) {\n        return;\n    }\n\n    const {\n        enemyAngleRange: [min, max]\n    } = enemyCoords;\n\n    const validatedAngle = angle === 360 ? 0 : angle;\n    const isEnemyInRange = validatedAngle > min && validatedAngle < max;\n\n    console.log(min, validatedAngle, max);\n    if (isEnemyInRange) {\n        enemyCoords = null;\n    }\n};\nconst changePointerDirection = () => {\n    pointerDirection = pointerDirection === clockwise ? сСlockwise : clockwise;\n    updateEnemyStatus();\n};\n\nlet isGameStarted: boolean = false;\nconst addListenerToStartGame = (listener: () => void) => {\n    const button = document.getElementById('button');\n\n    button.addEventListener('keydown', event => event.preventDefault());\n    button.addEventListener('click', () => {\n        if (!isGameStarted) {\n            isGameStarted = true;\n            listener();\n            document.body.focus();\n        }\n    });\n};\nsetDocumentListener(changePointerDirection);\n\naddListenerToStartGame(startGame);\n","import './src/game/';\n"]}