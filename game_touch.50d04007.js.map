{"version":3,"sources":["src/model/game.model.ts","src/helpers/radiant-transformer.ts","src/helpers/randomizer.ts","src/game/index.ts","index.ts"],"names":[],"mappings":"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","file":"game_touch.50d04007.js","sourceRoot":"..","sourcesContent":["export interface Game {\n    name: string;\n    level: number;\n    score: number;\n}\n\nexport interface MiddleCoordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Field {\n    radius: number;\n    backgroundColor: number;\n    middleCoordinate: MiddleCoordinate;\n}\n\nexport enum direction {\n    clockwise = -1,\n    сСlockwise = 1\n}\n\nexport interface Pointer {\n    direction: direction;\n    color: string;\n    angle: number;\n}\n\nexport interface Switcher {\n    rootAngle: number;\n    offsets: number;\n}\n","export const getRadians = (degrees: number) => (Math.PI / 180) * degrees;\n","export const randomIntegerInRange = (min: number, max: number): number =>\n    Math.floor(min + Math.random() * (max + 1 - min));\n","import { MiddleCoordinate, direction } from '../model/game.model';\nimport { getRadians } from '../helpers/radiant-transformer';\nimport { randomIntegerInRange } from '../helpers/randomizer';\n\nconst { clockwise, сСlockwise } = direction;\nconst domRectList = document.body.getClientRects();\nconst { width, height } = domRectList[0];\n\nconst canvasSize = width > height ? height : width;\nconst canvasMiddlePosition = canvasSize / 2;\nconst radius = canvasMiddlePosition * 0.9;\nconst innerRadius = radius / 3;\nconst minimumEnemyOffset = 20;\n\nconst canvasMiddlePoint: MiddleCoordinate = {\n    x: canvasMiddlePosition,\n    y: canvasMiddlePosition\n};\n\nconst { x, y } = canvasMiddlePoint;\nlet angle = 179;\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\nctx.canvas.width = canvasSize;\nctx.canvas.height = canvasSize;\nctx.canvas.style.backgroundColor = 'white';\n\nconst setStaticFigures = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 1;\n    canvasCtx.strokeStyle = 'black';\n    canvasCtx.lineJoin = 'bevel';\n\n    canvasCtx.arc(x, y, radius, 0, getRadians(360));\n    canvasCtx.stroke();\n\n    canvasCtx.beginPath();\n    canvasCtx.arc(x, y, innerRadius, 0, getRadians(360));\n    canvasCtx.stroke();\n};\n\nlet pointerDirection = clockwise;\n\nconst setDocumentListener = (listener: () => void) => {\n    document.addEventListener('click', listener);\n    document.addEventListener('keydown', listener);\n};\nconst drowPointer = (angle: number, canvasCtx: CanvasRenderingContext2D, usedColor: string) => {\n    const angleRad = getRadians(angle);\n    const xPosition = radius * Math.sin(angleRad) + x;\n    const yPosition = radius * Math.cos(angleRad) + y;\n\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 4;\n    canvasCtx.lineJoin = 'round';\n    canvasCtx.strokeStyle = usedColor;\n    canvasCtx.moveTo(x, y);\n\n    canvasCtx.lineTo(xPosition, yPosition);\n    canvasCtx.stroke();\n};\n\nconst getUpdatedAngle = (updatedAngle: number, direction: number) => {\n    return direction === clockwise ? (updatedAngle <= 0 ? 360 : updatedAngle) : updatedAngle >= 360 ? 0 : updatedAngle;\n};\n\nconst performPointerItaration = (canvasCtx: CanvasRenderingContext2D) => {\n    drowPointer(angle, canvasCtx, 'blue');\n    angle = getUpdatedAngle(angle + pointerDirection, pointerDirection);\n};\n\nconst calclulateEnemy = (angle: number) => {\n    const minEnemyPosition = Math.abs(angle % 360) + minimumEnemyOffset;\n    const maxEnemyPosition = minEnemyPosition + 360 - minimumEnemyOffset;\n\n    const middlePointAngle = randomIntegerInRange(minimumEnemyOffset, maxEnemyPosition) % 360;\n    const distanceFromMiddlePoint = randomIntegerInRange(innerRadius, radius * 0.9);\n    const enemyRadius = randomIntegerInRange(innerRadius * 0.1, innerRadius * 0.4);\n\n    const angleRad = getRadians(middlePointAngle);\n    const xPosition = distanceFromMiddlePoint * Math.sin(angleRad) + x;\n    const yPosition = distanceFromMiddlePoint * Math.cos(angleRad) + y;\n\n    const angleOffset = (Math.atan(enemyRadius / distanceFromMiddlePoint) * 180) / Math.PI;\n\n    const min = middlePointAngle - angleOffset;\n    const max = middlePointAngle + angleOffset;\n\n    return {\n        xPosition,\n        yPosition,\n        enemyRadius,\n        middlePointAngle,\n        enemyAngleRange: [min, max]\n    };\n};\n\nlet enemyCoords: any;\nconst drowEnemy = (angle: number, canvasCtx: CanvasRenderingContext2D) => {\n    if (!enemyCoords) {\n        enemyCoords = calclulateEnemy(angle);\n    }\n\n    const { xPosition, yPosition, enemyRadius } = enemyCoords;\n\n    canvasCtx.beginPath();\n    canvasCtx.lineWidth = 1;\n    canvasCtx.strokeStyle = 'red';\n\n    canvasCtx.arc(xPosition, yPosition, enemyRadius, 0, getRadians(360));\n    canvasCtx.stroke();\n};\n\nconst performCleanUp = (canvasCtx: CanvasRenderingContext2D) => {\n    canvasCtx.beginPath();\n    canvasCtx.fillStyle = 'white';\n    canvasCtx.fillRect(0, 0, canvasSize, canvasSize);\n};\n\nconst startGame = () => {\n    setInterval(() => {\n        performCleanUp(ctx);\n        setStaticFigures(ctx);\n        performPointerItaration(ctx);\n        drowEnemy(angle, ctx);\n    }, 10);\n};\n\nconst updateEnemyStatus = () => {\n    if (!enemyCoords) {\n        return;\n    }\n\n    const {\n        enemyAngleRange: [min, max]\n    } = enemyCoords;\n\n    const validatedAngle = angle === 360 ? 0 : angle;\n    const isEnemyInRange = validatedAngle > min && validatedAngle < max;\n\n    if (isEnemyInRange) {\n        enemyCoords = null;\n    }\n};\nconst changePointerDirection = () => {\n    pointerDirection = pointerDirection === clockwise ? сСlockwise : clockwise;\n    updateEnemyStatus();\n};\n\nlet isGameStarted: boolean = false;\nconst addListenerToStartGame = (listener: () => void) => {\n    const button = document.getElementById('button');\n\n    if (!button) {\n        return;\n    }\n\n    button.addEventListener('keydown', event => event.preventDefault());\n    button.addEventListener('click', () => {\n        if (!isGameStarted) {\n            isGameStarted = true;\n            listener();\n            document.body.focus();\n        }\n    });\n};\nsetDocumentListener(changePointerDirection);\n\naddListenerToStartGame(startGame);\n","import './src/game/';\n"]}